#!/home/wayne/public_html/projects/Fab/squashfs-root/usr/bin/python
"""CQtoFC: A module for reading CadQuery generated STEP files into FreeCAD.

This shell script converts the JSON file (.json) and associated STEP (.stp) files generated by
from a FabProject and converts them into FreeCAD document files (.FCStd) and optionally
generates CNC G code (`.ngc`) files.

This program is meant to be run by the FreeCAD Python interpreter.  Since there is no easy
way to pass command line arguments the interpreter, there is a shell file called `cq2fc.sh`
sets everything up to run in FreeCAD.  It passes arguments/options in via Environment variables.
(This very is a very crude but effective workaround to the problem.)  If you want to manually
run this from the command line, the following syntax should work:
```
FLAGS="c" JSON="/tmp/TestProject.json" ./freecad19 -c ./CQtoFC.py
```
Where `FLAGS="..."` sets the `FLAGS` environment variable and `JSON="..."` sets the `JSON`
environment variable for just one execution of the freecad19 python interpreter in -c
(console mode).  The `CQtoFC.py` file is this program.
"""

# <--------------------------------------- 100 characters ---------------------------------------> #

# In order to support debugging with the `pudb` Python debugger, it is necessary to run
# outside of the freecad19 Python interpreter.  The freecad19 Python interpreter puts the
# console into a weird mode that does not work with `pudb` debugger.  In order to set up
# debugging.  Do the following:
# ```
# python3 -m pip install pudb  # Only needs to be done once.  It lands in `~/.local/lib/...`
# rm -rf squashfs  # Remove any previously unpacked AppImage files.
# ./freecad19 --appimage-extract  # Extract new AppImage files.
# # Manually copy `pudb` into the `squashfs1 tree (unclear that this is necessary):
# cp -r ~/.local/lib/python3.8/site-packages/pudb ./squashfs-root/usr/lib/python3.8/site-packages/
# ```
# To enable `pudb`, uncomment `import pudb` and `pudb.start()`:
# TODO: Replace `/home/wayne` imediately below and in the first line of this file.
SHARP_EXEC_PATH = "/home/wayne/public_html/projects/Fab/squashfs-root/usr/bin/python"
import sys
if sys.executable == SHARP_EXEC_PATH:
    sys.path[1:1] = [  # Insert list into sys.path at index 1.
        "/home/wayne/public_html/projects/Fab/squashfs-root/usr/lib",
        "/home/wayne/public_html/projects/Fab/squashfs-root/usr/Ext",
        "/home/wayne/public_html/projects/Fab/squashfs-root/usr/bin",
        "/home/wayne/.local/lib/python3.8/site-packages",
    ]

from typing import Any, cast, List, Dict, IO, Optional, Set, Tuple, Union
from pathlib import Path as FilePath  # The Path library uses `Path`, hence `FilePath`

# Uncomment these lines to fire up the debugger:
# import pudb  # type: ignore
# pudb.start()  # Start it right now:

# Standard Python library imports:
from dataclasses import dataclass, field
import json
import os
# from pathlib import Path as PathFile

# Generic FreeCAD imports.  Note these imports add a long list of Python packages to `sys.path`.
import FreeCAD  # type: ignore
import FreeCADGui  # type: ignore
_ = FreeCAD
_ = FreeCADGui

# import Path  # type: ignore
# import PathScripts  # type: ignore
from PathScripts import PathOp, PathUtils  # type: ignore
from PathScripts import PathToolBit, PathDrilling  # type: ignore
from PathScripts import PathJob, PathProfile, PathPostProcessor, PathUtil  # type: ignore
from PathScripts import PathToolController, PathPocket  # type: ignore
import Path  # type: ignore
_ = PathOp  # TODO: remove
_ = PathUtils  # TODO: remove
_ = PathToolBit  # TODO: remove
_ = PathJob  # TODO: remove
_ = PathProfile  # TODO: remove
_ = PathPostProcessor  # TODO: remove
_ = PathUtil  # TODO: remove
_ = PathToolController  # TODO: remove
_ = PathPocket  # TODO: remove


# This causes out flake8 to think App are defined.
# It is actually present in the FreeCAD Python exectution envriorment.
App: Any
if False:
    App = None

# FreeCAD has two different importers depending upon whether it is GUI mode or not.
from FreeCAD import Vector  # type: ignore
if App.GuiUp:  # type: ignore
    import FreeCADGui as Gui  # type: ignore
    from FreeCAD import ImportGui as FCImport  # type: ignore
    from PathScripts import PathJobGui  # type: ignore
    _ = PathJobGui  # TODO: Remove
else:
    from FreeCAD import Import as FCImport  # type: ignore


# FabCQtoFC:
@dataclass
class FabCQtoFC(object):
    """FabCQtoFC: Import CadQuery .step files into FreeCAD."""

    JsonPath: FilePath
    ToolsPath: Optional[FilePath]
    CNC: bool
    AllDocuments: List[Any] = field(init=False, repr=False)
    CurrentGroup: Any = field(init=False, repr=False)
    CurrentJob: Any = field(init=False, repr=False)
    CurrentJobName: Any = field(init=False, repr=False)
    CurrentSolid: Any = field(init=False, repr=False)
    CurrentSolidName: Any = field(init=False, repr=False)
    CurrentLink: Any = field(init=False, repr=False)
    CurrentNormal: Any = field(init=False, repr=False)
    PendingLinks: List[Tuple[Any, Any]] = field(init=False, repr=False)
    ProjectDocument: Any = field(init=False, repr=False)
    StepsDocument: Any = field(init=False, repr=False)
    ToolControllersTable: Dict[int, Any] = field(init=False, repr=False)  # Ctl# => controller
    ToolNumbersTable: Dict[int, Any] = field(init=False, repr=False)  # Tool# => tool
    ToolsTable: Dict[str, Any] = field(init=False, repr=False)  # Tool name => tool

    # FabCQtoFC.__post_init__():
    def __post_init__(self) -> None:
        """Initialize FabCQtoFC."""
        assert isinstance(self.JsonPath, FilePath), self.JsonPath
        self.AllDocuments = []
        self.CurrentGroup = None
        self.CurrentJob = None
        self.CurrentJobName = None
        self.CurrentLink = None
        self.CurrentNormal = None
        self.CurrentSolid = None
        self.CurrentSolidName = None
        self.PendingLinks = []
        self.ProjectDocument = None
        self.ProperitiesVerified = False
        self.StepsDocument = None
        self.ToolControllersTable = {}
        self.ToolNumbersTable = {}
        self.ToolsTable = {}

    # FabCQtoFC.fetch_tool():
    def fetch_tool(self, bit_name: str) -> Any:
        """Fetch a tool from the Tools/Bit and store into ToolsTable."""
        tools_table: Dict[str, Any] = self.ToolsTable
        if bit_name not in tools_table:
            # Create the *bit_path* file name and verify that it exists:
            assert isinstance(self.ToolsPath, FilePath), f"{type(self.ToolsPath)=}"
            bit_directory: FilePath = self.ToolsPath / "Bit"
            bit_path: FilePath = bit_directory / f"{bit_name}.fctb"
            if not bit_path.exists():
                raise RuntimeError(f"{str(bit_path)} file does not exist")

            # Read *bit_path* contents in and convert into *bit_json*:
            bit_file: IO[str]
            with open(bit_path, "r") as bit_file:
                bit_text: str = bit_file.read()
            bit_json: Any = json.loads(bit_text)

            # Convert *bit_json* into *tool* and save it:
            tool: Any = PathToolBit.Factory.CreateFromAttrs(bit_json, bit_name)
            tool.Visibility = False
            tools_table[bit_name] = tool
        return tools_table[bit_name]

    # FabCQtoFC.get_tool_and_controller():
    def get_tool_and_controller(
            self, json_dict: Dict[str, Any], label: str, indent: str, tree_path: Tuple[str, ...],
            tracing: str = "") -> Tuple[Any, Any]:
        """Extract tool controller and associated tool bit from a JSON node."""
        if tracing:
            print(f"{tracing}=>FabCQtotFC.get_tool_and_controller(*, {label}, {tree_path})")
        tool_controller_index = cast(
            int, self.key_verify("ToolControllerIndex", json_dict, int,
                                 tree_path, "get_tool_and controller.ToolControllerIndex"))
        tool_controllers_table: Dict[int, Any] = self.ToolControllersTable
        tool: Any
        tool_controller: Any
        if tool_controller_index in tool_controllers_table:
            tool_controller = tool_controllers_table[tool_controller_index]
            tool = tool_controller.Tool
        else:
            # Extract the *tool_controller_dict* from *json_dict*:
            tool_controller_dict = cast(
                Dict[str, Any], self.key_verify(
                    "ToolController", json_dict, dict,
                    tree_path, "get_tool_and controller.ToolController"))

            # Extract the tool controller fields from *json_dict*:
            bit_name = cast(
                str, self.key_verify(
                    "BitName", tool_controller_dict, str,
                    tree_path, "get_tool_and controller.BitName"))
            cooling = cast(
                str, self.key_verify(
                    "Cooling", tool_controller_dict, str,
                    tree_path, "get_tool_and controller.Cooling"))
            horizontal_feed = cast(
                float, self.key_verify(
                    "HorizontalFeed", tool_controller_dict, float,
                    tree_path, "get_tool_and controller.HoriztontalFeed"))
            horizontal_rapid = cast(
                float, self.key_verify(
                    "HorizontalRapid", tool_controller_dict, float,
                    tree_path, "get_tool_and controller.HoriztontalRapid"))
            spindle_direction = cast(
                bool, self.key_verify(
                    "SpindleDirection", tool_controller_dict, bool,
                    tree_path, f"get_tool_and controller.SpindleDirection {tool_controller_dict}"))
            spindle_speed = cast(
                float, self.key_verify(
                    "SpindleSpeed", tool_controller_dict, float,
                    tree_path, "get_tool_and controller.SpindleSpeed"))
            tool_number = cast(
                int, self.key_verify(
                    "ToolNumber", tool_controller_dict, int,
                    tree_path, "get_tool_and controller.ToolNumber"))
            vertical_feed = cast(
                float, self.key_verify(
                    "VerticalFeed", tool_controller_dict, float,
                    tree_path, "get_tool_and controller.VerticalFeed"))
            vertical_rapid = cast(
                float, self.key_verify(
                    "VerticalRapid", tool_controller_dict, float,
                    tree_path, "get_tool_and controller.VerticalRapid"))
            _ = cooling  # Extremely weird, tool controllers do not cooling.

            # Create the *tool_controller*:
            tool_controller = PathToolController.Create(name=label)

            # Look up the *tool* using *tool_number* and/or *bit_name*:
            if tool_number in self.ToolNumbersTable:
                tool = self.ToolNumbersTable[tool_number]
            else:
                tool = self.fetch_tool(bit_name)
                self.ToolNumbersTable[tool_number] = tool
            tool_controller.Tool = tool

            # A helper method to fill in the *tool_controller* fields:
            def tool_controller_set(tool_controller: Any, attribute_name: str,
                                    value: Union[int, str, float]) -> None:
                """Set a field value in the tool controller."""
                if hasattr(tool_controller, attribute_name):
                    # Make sure that there is no expression present for *attribute_name*.
                    # If this is not done, the following value set does not "take".
                    tool_controller.setExpression(attribute_name, None)
                    setattr(tool_controller, attribute_name, value)
                else:
                    raise RuntimeError(f"ToolController does not have Attribute {attribute_name}")

            # Load up the contents of *tool_controller*:
            tool_controller_set(tool_controller, "HorizFeed", horizontal_feed)
            tool_controller_set(tool_controller, "HorizRapid", horizontal_rapid)
            tool_controller_set(tool_controller, "SpindleDir", spindle_direction)
            tool_controller_set(tool_controller, "SpindleSpeed", spindle_speed)
            tool_controller_set(tool_controller, "ToolNumber", tool_number)
            tool_controller.Tool = tool
            tool_controller_set(tool_controller, "VertFeed", vertical_feed)
            tool_controller_set(tool_controller, "VertRapid", vertical_rapid)
            # Weird! There is to coolant field in a tool controller yet.
            tool_controllers_table[tool_controller_index] = tool_controller

        result: Tuple[Any, Any] = (tool, tool_controller)
        if tracing:
            print(f"{tracing}<=FabCQtotFC.get_tool_and_controller("
                  f"*, {label}, {tree_path})=>{result}")
        return result

    # FabCQtoFC.flush_job(self):
    def flush_job(self, tracing: str = ""):
        if tracing:
            print(f"{tracing}=>FabCQtoFC.flush_job()")
        job: Any = self.CurrentJob
        job_name: Any = self.CurrentJobName
        if job:
            # Create *post_list* which is a list of tool controllers and *operations*:
            post_list: List[Any] = []
            current_tool_number: int = -99999999
            for index, operation in enumerate(job.Operations.Group):
                tool_controller: Any = PathUtil.toolControllerForOp(operation)
                tool: Any = tool_controller.Tool
                if tracing:
                    print(f"{tracing}{tool=}")

                if tool_controller is not None:
                    if tool_controller.ToolNumber != current_tool_number:
                        post_list.append(tool_controller)
                        current_tool_number = tool_controller.ToolNumber
                post_list.append(operation)

            # Generate the gcode and output it to *gcode_path*:
            gcode_path = f"/tmp/{job_name}.ngc"
            post: Any = PathPostProcessor.PostProcessor.load(job.PostProcessor)
            post.export(post_list, gcode_path, job.PostProcessorArgs)

        self.CurrentJob = None
        self.CurrentJobName = None
        if tracing:
            print(f"{tracing}<=FabCQtoFC.flush_job()")

    # CQtoPy.verify_properties():
    def verify_properties(self, tracing: str = "") -> None:
        """Verify that all of the properties match their associated 'info' dictionaries."""
        # This method must be called after a document has been created.
        if tracing:
            print(f"{tracing}=>CQtoPy.verify_properties()")

        def match(label: str, properties: Set[str], infos: Set[str]) -> None:
            """Match a properties with information set."""
            if properties != infos:
                print(f"CQtoPy.verify_properties.match('{label}') <<<<<<<<<<<<<<<<:")
                # print(f"{sorted(properties)=}")
                # print(f"{sorted(infos)=}")
                # print()
                print(f"{sorted(properties - infos)=}")
                print(f"{sorted(infos - properties)=}")
                assert False

        def append_documentation(obj: Any, out_file: IO[str], label: str) -> None:
            """Output object documentation to an opened file."""
            name: str
            lines: List[str] = [f"\n## {label}:"]
            for name in sorted(obj.PropertiesList):
                value: Any = getattr(obj, name)
                documentation = cast(str, obj.getDocumentationOfProperty(name))

                # Create a realatively clean *type_name*:
                type_name: str = str(type(value))
                if type_name.startswith("<class '") and type_name.endswith("'>"):
                    type_name = type_name[8:-2]
                if type_name == "Base.Quantity":
                    type_name = "float"
                elif type_name == "Base.Vector":
                    type_name = "Vector"

                # Convert *enumerations* into a more readable *enumerations_text*:
                enumerations: Optional[List[str]] = None
                enumerations_text: str = ""
                enumerations = obj.getEnumerationsOfProperty(name)
                if enumerations:
                    enumeration: str
                    enumerations = [f"'{enumeration}'" for enumeration in enumerations]
                    enumerations_text = f" {{ {', '.join(sorted(enumerations))} }}"
                lines.append(f"* {name} ({type_name}): {documentation}{enumerations_text}")
            lines.append("")
            out_file.write("\n".join(lines))

        self.ProperitiesVerified = True
        if not self.ProperitiesVerified:
            self.ProperitiesVerified = True

            # Create a temporary operation object to extract properties from:
            profile: Any = PathProfile.Create("IgnoreThisProfile")
            profiles: Set[str] = set(profile.PropertiesList)
            pocket: Any = PathPocket.Create("IgnoreThisPocket")  # => "Path::FeaturePython".
            pockets: Set[str] = set(pocket.PropertiesList)
            drilling: Any = PathDrilling.Create("IgnoreThisDrilling")
            drillings: Set[str] = set(drilling.PropertiesList)
            commons: Set[str] = profiles & pockets & drillings

            # Write out property documentation:
            out_file: IO[str]
            with open("/tmp/objects.md", "w") as out_file:
                out_file.write("# Object Docuementation\n")
                append_documentation(profile, out_file, "Profile")
                append_documentation(pocket, out_file, "Pocket")
                append_documentation(drilling, out_file, "Drilling")

            # Remove the temporary opration objects:
            project_document: Any = self.ProjectDocument
            project_document.removeObject("IgnoreThisProfile")
            project_document.removeObject("IgnoreThisPocket")
            project_document.removeObject("IgnoreThisDrilling")

            # Extract the information dictionary keys as sets:
            common_infos: Set[str] = set(self.merge_common_infos({}))
            extrude_infos: Set[str] = set(self.get_extrude_infos().keys())
            pocket_infos: Set[str] = set(self.get_pocket_infos().keys())
            drilling_infos: Set[str] = set(self.get_drilling_infos().keys())

            match("commmon", commons, common_infos)
            match("pocket", pockets, pocket_infos)
            match("profile", profiles, extrude_infos)
            match("drilling", drillings, drilling_infos)
        if tracing:
            print(f"{tracing}<=CQtoPy.verify_properties()")

    # FabCQtoFC.process():
    def process(self, indent: str = "", tracing: str = "") -> None:
        """Process a JSON file into a FreeCAD documents."""
        next_tracing: str = tracing + "  " if tracing else ""
        if tracing:
            print(f"{tracing}=>FabCQtFC.process({str(self.JsonPath), {self.ToolsPath}})")

        # Create the *steps_document*:
        json_directory: FilePath = self.JsonPath.parent
        steps_document: Any = App.newDocument("Step_Files")  # type: ignore
        self.StepsDocument = steps_document
        self.AllDocuments.append(steps_document)

        # Read in *json_path*:
        json_file: IO[str]
        json_text: str = ""
        if self.JsonPath.suffix != ".json":
            raise RuntimeError(f"JSON file must have `.json` suffix: '{str(self.JsonPath)}'")
        if tracing:
            print(f"{tracing}Loading {str(self.JsonPath)}")
        with open(self.JsonPath, "r") as json_file:
            json_text = json_file.read()
        if tracing:
            print(f"{tracing}Parsing {str(self.JsonPath)}")
        json_root = cast(Dict[str, Any], json.loads(json_text))
        assert isinstance(json_root, dict), json_root

        # Recursively walk the tree starting at *json_root*:
        if tracing:
            print(f"{tracing}Processing {str(self.JsonPath)}")
        self.node_process(("Root",), json_root, indent=indent, tracing=next_tracing)

        # Save *all_documents*:
        document: Any
        for document in self.AllDocuments:
            save_path: FilePath = json_directory / f"{document.Label}.FCStd"
            if save_path.exists():
                save_path.unlink()
            document.recompute()
            document.saveAs(str(save_path))
        self.flush_job()

        # Install all of the *pending_links*:
        pending_link: Tuple[Any, Any]
        link: Any
        part: Any
        for link, part in self.PendingLinks:
            link.setLink(part)
        if tracing:
            print(f"{tracing}<=FabCQtFC.process({str(self.JsonPath), {self.ToolsPath}})")

    # FabCQtoFC.type_verify():
    def type_verify(self, value: Any, value_type: type,
                    tree_path: Tuple[str, ...], tag: str) -> None:
        """Verify JSON type."""
        if not isinstance(value, value_type):
            message: str = f"{tree_path}: {tag}: Got {type(value)}, not {value_type}"
            print(message)
            assert False, message

    # FabCQtoFC.key_verify():
    def key_verify(self, key: str, table: Dict[str, Any], key_type: type,
                   tree_path: Tuple[str, ...], tag: str) -> Any:
        """Verify key is in dictionary and has correct type."""
        if key not in table:
            message: str = f"{tree_path}: {tag}: '{key}' is not one of {tuple(table.keys())}'"
            print(message)
            assert False, message
        value: Any = table[key]
        self.type_verify(value, key_type, tree_path, tag)
        return value

    # FabCQtoFC.process_json():
    def process_json(
            self, json_dict: Dict[str, Any], obj: Any,
            infos: Dict[str, Dict[str, Any]], tracing: str = ""
    ) -> None:
        """Transfer JSON values into Path operation object.

        Arguments:
        * *json_dict* (Dict[str, Any]):
          A dictionary from a JSON file that contains the object values:
        * *obj* (Any):
          A Path operation object (e.g. contour, pocket, drill, etc.) that has properties
          to be set.  This object must have a `PropertiesList` attribute.
        * *infos* (Dict[str, Dict[str, Any]]):
          This a dictionary of dictionaries.  The top level dictionary keys must be 1-to-1
          with the keys returned by the `PropertiesList` attribute.  The sub-dictionary for
          each property specifies additional information:
          * "type": (type): When present, the property must match this type.
          * "ignore: (None): When present, this property is ignored.
        """
        if tracing:
            print(f"{tracing}=>FabCQtoFC.process_json(*, *, *)")

        # Verify that required methods are present:  # TODO: Move to verify_properties:
        if not hasattr(obj, "PropertiesList"):
            raise RuntimeError(
                "FabCQtoFC.process_json(): No getProperties() method present")
        if not hasattr(obj, "getDocumentationOfProperty"):
            raise RuntimeError(
                "FabCQtoFC.process_json(): No getDocumentationOfProperty() method present")

        # Extract *ignores* (fields not expected in JSON) from *info*:
        name: str
        info: Dict[str, Any]
        ignores: Set[str] = {  # Set comprehension
            name for name, info in infos.items() if "ignore" in info}
        actuals: Set[str] = set(obj.PropertiesList)

        # The incoming JSON entries have a preceding "_" that needs to be stripped off.
        # FYI, the "_" ensures that required entries like "Label" and "Kind" get sorted first
        # when the JSON is pretty printed.  Any following "children" list always sorts last.
        jsons: Set[str] = set([
            name[1:] for name in json_dict.keys() if name.startswith("_")])

        desired_jsons: Set[str] = jsons
        desired_actuals: Set[str] = actuals - ignores
        if desired_jsons != desired_actuals:
            raise RuntimeError(
                "FabCQtoFC.process_json(): Property mismatch:\n"
                f"{sorted(desired_jsons - desired_actuals)=}\n"
                f"{sorted(desired_actuals - desired_jsons)=}\n"
            )

        # Sweep through *properties*:
        if tracing:
            print(f"{tracing}{jsons=}")
        for name, info in infos.items():
            info_key: str
            info_value: Any
            if "ignore" not in info:
                target_value: Any = getattr(obj, name)
                target_type: type = type(target_value)
                json_value: Any = json_dict[f"_{name}"]  # JSON keys have "_" key prefix.
                json_type: type = type(json_value)
                if "type" in info:
                    target_type = info["type"]
                # TODO: Should not assume that all strings are enumerations:
                if isinstance(json_type, str):
                    enumerations: List[str] = obj.getEnumererationsOfProperty(name)
                    if json_value not in enumerations:
                        raise RuntimeError(
                            f"FabCQtoFC.process_json(): {name=} has "
                            f"{target_value=} which is not one of {sorted(enumerations)}")
                if target_type != json_type:
                    raise RuntimeError(
                        "FabCQtoFC.process_json(): "
                        f"{name=}: {target_type=} != {json_type=}")
                setattr(obj, name, json_value)

        if tracing:
            print(f"{tracing}<=FabCQtoFC.process_json(*, *, *)")

    # FabCQtoFC.node_process():
    def node_process(self, tree_path: Tuple[str, ...], json_dict: Dict[str, Any],
                     indent: str = "", tracing: str = "") -> None:
        """Process one 'node' of JSON content."""

        # Set up *tracing* and pretty print *indent*:
        next_tracing: str = tracing + "  " if tracing else ""
        next_indent = indent + "  " if indent else ""
        if tracing:
            print(f"{tracing}=>FabCQtoFC.child_process(*, {tree_path}, '{indent}')")
            print(f"{tracing}{json_dict=}")

        # Do some sanity checking:
        error_message: str
        self.type_verify(json_dict, dict, tree_path, "json_dict")
        kind = cast(str, self.key_verify("Kind", json_dict, str, tree_path, "Kind"))
        label = cast(str, self.key_verify("Label", json_dict, str, tree_path, "Label"))
        if indent:
            print(f"{indent}{label}:")
            print(f"{indent} Kind: {kind}")

        # Verify that that *kind* is one of the *allowed_kinds*:
        allowed_kinds: Tuple[str, ...] = (
            "Project", "Document", "Assembly", "Solid", "Mount",  # No operations
            "Extrude", "Pocket", "Drilling")  # Operations
        if kind not in allowed_kinds:
            error_message = f"{tree_path}: Node kind '{kind}' not one of {allowed_kinds}"
            print(error_message)
            assert False, error_message

        # Dispatch on *kind*:
        if kind == "Project":
            pass
        elif kind == "Document":
            self.process_document(json_dict, label, indent, tree_path, tracing=next_tracing)
        elif kind == "Assembly":
            self.process_assembly(json_dict, label, indent, tree_path, tracing=next_tracing)
        elif kind == "Solid":
            self.process_solid(json_dict, label, indent, tree_path, tracing=next_tracing)
        elif kind == "Mount":
            self.process_mount(json_dict, label, indent, tree_path, tracing=next_tracing)
        elif kind == "Extrude":
            self.process_extrude(json_dict, label, indent, tree_path, tracing=next_tracing)
        elif kind == "Pocket":
            self.process_pocket(json_dict, label, indent, tree_path, tracing=next_tracing)
        elif kind == "Drilling":
            # self.process_drilling(json_dict, label, indent, tree_path, tracing=next_tracing)
            pass
        else:
            message = f"'{kind}' not one of {allowed_kinds}"
            print(message)
            assert False, message

        # Recursively process any *chidren* JSON nodes:
        if "children" in json_dict:
            children = cast(List[Dict[str, Any]],
                            self.key_verify("children", json_dict, list, tree_path, "Children"))
            if indent:
                print(f"{indent} children ({len(children)}):")

            child_dict: Dict[str, Any]
            for child_dict in children:
                self.type_verify(child_dict, dict, tree_path, "Child")
                child_name = cast(str,
                                  self.key_verify("Label", child_dict, str, tree_path, "Label"))
                child_tree_path: Tuple[str, ...] = tree_path + (child_name,)
                self.node_process(child_tree_path, child_dict,
                                  indent=next_indent, tracing=next_tracing)
        if tracing:
            print(f"{tracing}<=FabCQtoFC.child_process({tree_path}, '{indent}')")

    # FabCQtoFC.process_assembly():
    def process_assembly(self, json_dict: Dict[str, Any], label: str,
                         indent: str, tree_path: Tuple[str, ...], tracing: str = "") -> None:
        if tracing:
            print(f"{tracing}=>FabCQtoFC.process_assembly(*, '{label}', {tree_path})")
        if self.CurrentGroup:
            self.CurrentGroup = self.CurrentGroup.newObject("App::DocumentObjectGroup", label)
        else:
            self.CurrentGroup = self.ProjectDocument.addObject("App::DocumentObjectGroup", label)
        if tracing:
            print(f"{tracing}<=FabCQtoFC.process_assembly(*, '{label}', {tree_path})")

    # FabCQtoFC.process_document():
    def process_document(self, json_dict: Dict[str, Any], label: str,
                         indent: str, tree_path: Tuple[str, ...], tracing: str = "") -> None:
        """Process a Document JSON node."""
        # next_tracing: str = tracing + " " if tracing else ""
        if tracing:
            print(f"{tracing}=>FabCQtoFC.process_document(*, '{label}', {tree_path})")
        file_path: str = cast(str, self.key_verify(
            "_FilePath", json_dict, str, tree_path, "Document._File_Path"))
        project_document = App.newDocument(label)  # type: ignore
        project_document.Label = label
        if indent:
            print(f"{indent} _FilePath: {file_path}")
            self.ProjectDocument = project_document
            self.AllDocuments.append(project_document)
        if tracing:
            print(f"{tracing}<=FabCQtoFC.process_document(*, '{label}', {tree_path})")

    # FabCQtoFC.process_extrude():
    def process_extrude(self, json_dict: Dict[str, Any], label: str,
                        indent: str, tree_path: Tuple[str, ...], tracing: str = "") -> None:
        """Process an Extrude JSON node."""
        next_tracing: str = tracing + " " if tracing else ""
        if tracing:
            print(f"{tracing}=>FabCQtoFC.process_extrude(*, '{label}', {tree_path})")
        active = cast(bool, self.key_verify("_Active", json_dict, bool, tree_path,
                                            "Extrude._Active"))
        if tracing:
            print(f"{tracing}Creating job")
        job = self.CurrentJob
        normal = self.CurrentNormal
        assert job is not None, "No job present"

        if active:
            tool, tool_controller = self.get_tool_and_controller(
                json_dict, label, indent, tree_path, tracing=next_tracing)

            self.verify_properties(tracing=next_tracing)
            profile_solid: Any = self.CurrentSolid
            profile_name: str = f"{job.Label}_profile"
            aligned_face_name: str = self.get_aligned_face_name(
                profile_solid, normal, tracing=next_tracing)
            if aligned_face_name:
                if tracing:
                    print(f"{tracing}Create profile")
                # This prints:
                # PathSetupSheet.INFO: SetupSheet has no support for TestSolid_Step_Top_profile
                # Modify PathProfile:1460 and 1464 to Job.
                # TODO: Any => PathProfile
                profile: Any = PathProfile.Create(profile_name, parentJob=job)
                if tracing:
                    print(f"{tracing}profile created")
                profile.Base = (profile_solid, aligned_face_name)
                if True:
                    step_file = cast(str, self.key_verify(
                        "StepFile", json_dict, str, tree_path, "Extrude._StepFile"))
                    depth = cast(float, self.key_verify(
                        "_Depth", json_dict, float, tree_path, "Extrude._Depth"))
                    final_depth = cast(float, self.key_verify(
                        "_FinalDepth", json_dict, float, tree_path, "Extrude._FinalDepth"))
                    step_down = cast(float, self. key_verify(
                        "_StepDown", json_dict, float, tree_path, "Extrude._StepDown"))
                    start_depth = cast(float, self.key_verify(
                        "_StartDepth", json_dict, float, tree_path, "Extrude._StartDepth"))
                    if indent:
                        print(f"{indent} StepFile: {step_file}")
                        print(f"{indent} _Contour: {bool}")
                        print(f"{indent} _Depth: {depth}")
                        print(f"{indent} _FinalDepth: {final_depth}")
                        print(f"{indent} _StartDepth: {start_depth}")
                        print(f"{indent} _StepDown: {step_down}")

                    profile.setExpression('StepDown', None)
                    profile.StepDown = step_down
                    profile.setExpression('StartDepth', None)
                    profile.StartDepth = start_depth
                    profile.setExpression('FinalDepth', None)
                    profile.FinalDepth = final_depth
                else:
                    pass  # Do process_json() here.

                profile.processHoles = False
                profile.processPerimeter = True
                profile.ToolController = tool_controller

                profile.recompute()

        if tracing:
            print(f"{tracing}<=FabCQtoFC.process_extrude(*, '{label}', {tree_path})")

    # FabCQtFC.merge_common_infos():
    def merge_common_infos(self, infos: Dict[str, Dict[str, Any]]) -> Dict[str, Dict[str, Any]]:
        """Return some common properties to ignore."""
        infos["Active"] = {}
        infos["Base"] = {"ignore": None}
        infos["ClearanceHeight"] = {"type": float}
        infos["Comment"] = {"ignore": None}
        infos["CoolantMode"] = {}
        infos["CycleTime"] = {"ignore": None}
        infos["EnableRotation"] = {"ignore": None}
        infos["ExpressionEngine"] = {"ignore": None}
        infos["FinalDepth"] = {"type": float}
        infos["Label"] = {"ignore": None}
        infos["Label2"] = {"ignore": None}
        infos["OpFinalDepth"] = {"ignore": None}
        infos["OpStartDepth"] = {"ignore": None}
        infos["OpStockZMax"] = {"ignore": None}
        infos["OpStockZMin"] = {"ignore": None}
        infos["OpToolDiameter"] = {"ignore": None}
        infos["Path"] = {"ignore": None}
        infos["Placement"] = {"ignore": None}
        infos["Proxy"] = {"ignore": None}
        infos["SafeHeight"] = {"type": float}
        infos["StartDepth"] = {"type": float}
        infos["ToolController"] = {"ignore": None}
        infos["UserLabel"] = {"ignore": None}
        infos["Visibility"] = {"ignore": None}

        return infos

    # FabCQtFC.get_drilling_infos():
    def get_drilling_infos(self) -> Dict[str, Any]:
        """Return the pocket properties."""
        drilling_infos: Dict[str, Any] = {
            "AddTipLength": {"ignore": None},
            "AttemptInverseAngle": {"ignore": None},
            "Disabled": {"ignore": None},
            "DwellEnabled": {"ignore": None},
            "DwellTime": {"ignore": None},
            "ExtraOffset": {},
            "InverseAngle": {"ignore": None},
            "Locations": {"ignore": None},
            "PeckDepth": {},
            "PeckEnabled": {},
            "RetractHeight": {"ignore": None},
            "ReturnLevel": {"ignore": None},
            "ReverseDirection": {"ignore": None},
        }
        self.merge_common_infos(drilling_infos)
        return drilling_infos

    # FabCQtFC.get_extrude_infos():
    def get_extrude_infos(self) -> Dict[str, Any]:
        """Return the pocket properties."""
        extrude_infos: Dict[str, Any] = {
            "AreaParams": {"ignore": None},
            "AttemptInverseAngle": {"ignore": None},
            "Direction": {},
            "HandleMultipleFeatures": {"ignore": None},
            "InverseAngle": {"ignore": None},
            "JoinType": {"ignore": None},
            "LimitDepthToFace": {"ignore": None},
            "MiterLimit": {"ignore": None},
            "OffsetExtra": {"ignore": None},
            "PathParams": {"ignore": None},
            "ReverseDirection": {"ignore": None},
            "Side": {"extra": None},
            "StartPoint": {"ignore": None},
            "StepDown": {"type": float},
            "UseComp": {"ignore": None},
            "UseStartPoint": {"ignore": None},
            "processCircles": {"ignore": None},
            "processHoles": {"ignore": None},
            "processPerimeter": {"ignore": None},
            "removalshape": {"ignore": None},
        }
        return self.merge_common_infos(extrude_infos)

    # FabCQtFC.get_pocket_infos():
    def get_pocket_infos(self) -> Dict[str, Any]:
        """Return the pocket properties."""
        pocket_infos: Dict[str, Any] = {
            "AdaptivePocketFinish": {"ignore": None},
            "AdaptivePocketStart": {"ignore": None},
            "AreaParams": {"ignore": None},
            "CutMode": {},
            "ExtraOffset": {"ignore": None},
            "FinishDepth": {"type": float},
            "HandleMultipleFeatures": {"ignore": None},
            "KeepToolDown": {},
            "MinTravel": {},
            "OffsetPattern": {},
            "PathParams": {"ignore": None},
            "Placement": {"ignore": None},
            "ProcessStockArea": {"ignore": None},
            "StartAt": {},
            "StartPoint": {"ignore": None},
            "StepDown": {"type": float},
            "StepOver": {},
            "UseStartPoint": {"ignore": None},
            "ZigZagAngle": {},
            "removalshape": {"ignore": None},
        }
        self.merge_common_infos(pocket_infos)
        return pocket_infos

    # FabCQtoFC.process_pocket():
    def process_pocket(self, json_dict: Dict[str, Any], label: str,
                       indent: str, tree_path: Tuple[str, ...], tracing: str = "") -> None:
        """Process a Pocket JSON node."""
        next_tracing: str = tracing + " " if tracing else ""
        if tracing:
            print(f"{tracing}=>FabCQtoFC.process_pocket(*, '{label}', {tree_path})")

        # Grab *pocket_bottom* from STEP file and insert into *project_document*:
        self.verify_properties(tracing=next_tracing)
        project_document: Any = self.ProjectDocument
        if tracing:
            print(f"{tracing}{project_document=} {project_document.Label=}")
        step = cast(str, self.key_verify(
            "StepFile", json_dict, str, tree_path, "Pocket.StepFile"))
        step_file: FilePath = FilePath(step)
        if tracing:
            print(f"{tracing}{step_file=}")
            print(f"{tracing}{step_file.stem=}")
        if not step_file.exists():
            raise RuntimeError(f"{step_file} does not exits.")
        FCImport.insert(step, project_document.Label)
        pocket_label: str = step_file.stem[:-18]  # strip off '__XXXXXXXXXXXXXXXX'
        if tracing:
            print(f"{tracing}{pocket_label=}")

        # *pocket_solid* is a rectangular block with (currently) 1 pocket cut into it:
        pocket_solid: Any = project_document.getObject(pocket_label)
        if tracing:
            print(f"{tracing}{pocket_solid=}")

        tool: Any = None
        tool_controller: Any = None
        tool, tool_controller = self.get_tool_and_controller(
            json_dict, label, indent, tree_path, tracing=next_tracing)
        App.ActiveDocument = project_document  # TODO: This should not be necessary
        if tracing:
            print(f"{tracing}{tool=} {tool_controller=}")

        # Now create the *pocket* object.  In this version of the Path library it finds
        # the one and only *job* object and attachtes to it.  The next version allows
        # the *job* object to be explicitly specified:
        job: Any = self.CurrentJob
        pocket: Any = PathPocket.Create(pocket_label, parentJob=job)  # => "Path::FeaturePython".

        normal: Vector = Vector(0.0, 0.0, 1.0)
        aligned_face_name: str = self.get_aligned_face_name(
            pocket_solid, normal, tracing=next_tracing)

        # [How to find Pockets in FreeCAD using Python Script?]
        #   (https://forum.freecad.org/viewtopic.php?f=22&p=579798)

        pocket.Base = (pocket_solid, aligned_face_name)
        pocket_infos: Dict[str, Any] = self.get_pocket_infos()
        _ = pocket_infos  # TODO: remove
        # self.process_json(json_dict, pocket, pocket_infos, tracing=next_tracing)
        pocket.recompute()

        if tracing:
            print(f"{tracing}<=FabCQtoFC.process_pocket(*, '{label}', {tree_path})")

    # FabCQtoFC.process_drilling():
    def process_drilling(self, json_dict: Dict[str, Any], label: str,
                         indent: str, tree_path: Tuple[str, ...], tracing: str = "") -> None:
        """Process a Drill JSON node."""
        next_tracing: str = tracing + " " if tracing else ""
        if tracing:
            print(f"{tracing}=>FabCQtoFC.process_drilling(*, '{label}', {tree_path})")

        # Grab *drill_solid* from STEP file and insert into *project_document*:
        self.verify_properties(tracing=next_tracing)
        project_document: Any = self.ProjectDocument
        if tracing:
            print(f"{tracing}{project_document=} {project_document.Label=}")
        # TODO: refactor Step file extraction():
        step = cast(str, self.key_verify(
            "StepFile", json_dict, str, tree_path, "Pocket.StepFile"))
        step_file: FilePath = FilePath(step)
        if tracing:
            print(f"{tracing}{step_file=}")
            print(f"{tracing}{step_file.stem=}")
        if not step_file.exists():
            raise RuntimeError(f"{step_file} does not exits.")
        FCImport.insert(step, project_document.Label)
        drilling_label: str = step_file.stem[:-18]  # strip off '__XXXXXXXXXXXXXXXX'
        if tracing:
            print(f"{tracing}{step_file=}")
            print(f"{tracing}{drilling_label=}")
        drilling_solid: Any = project_document.getObject(drilling_label)
        if tracing:
            print(f"{tracing}{drilling_solid=}")

        tool: Any = None
        tool_controller: Any = None
        tool, tool_controller = self.get_tool_and_controller(
            json_dict, label, indent, tree_path, tracing=next_tracing)
        App.ActiveDocument = project_document  # TODO: This should not be necessary
        if tracing:
            print(f"{tracing}{tool=} {tool_controller=}")

        # Now create a PathDrilling object:
        job: Any = self.CurrentJob
        drilling: Any = PathDrilling.Create(drilling_label, parentJob=job)

        # z_axis: Vector = Vector(0.0, 0.0, 1.0)
        # aligned_face_name: str = self.get_aligned_face_name(
        #     drilling_solid, z_axis, tracing=next_tracing)
        # _ = aligned_face_name
        # drilling.Base = (drilling_solid, aligned_face_name)
        drilling_infos: Dict[str, Any] = self.get_drilling_infos()
        self.process_json(json_dict, drilling, drilling_infos, tracing=next_tracing)
        drilling.recompute()

        if tracing:
            print(f"{tracing}<=FabCQtoFC.process_drilling(*, '{label}', {tree_path})")

    # FabCQtoFC.process_mount():
    def process_mount(self, json_dict: Dict[str, Any], label: str,
                      indent: str, tree_path: Tuple[str, ...], tracing: str = "") -> None:
        """Process a Mount JSON node."""
        next_tracing: str = tracing + " " if tracing else ""
        if tracing:
            print(f"{tracing}=>FabCQtotFC.process_mount(*, {label}, {tree_path})")
        contact_list: List[float] = cast(
            list, self.key_verify("_Contact", json_dict, list, tree_path, "Solid._Contact"))
        normal_list: List[float] = cast(
            list, self.key_verify("_Normal", json_dict, list, tree_path, "Solid._Normal"))
        orient_list: List[float] = cast(
            list, self.key_verify("_Orient", json_dict, list, tree_path, "Solid._Orient"))
        contact: Vector = Vector(contact_list)
        normal = Vector(normal_list)
        orient: Vector = Vector(orient_list)
        if indent:
            print(f"{indent} _Contact: {contact}")
            print(f"{indent} _Normal: {normal}")
            print(f"{indent} _Orient: {orient}")

        self.flush_job(tracing=next_tracing)  # Force previous job to be done.

        # # Delete any previous jobs:
        # if tracing:
        #     print(f"{tracing}>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
        #     print(f"{tracing}Before: {PathJob.Instances()=}")
        # job: Any
        # for job in PathJob.Instances():
        #     print(f"{tracing}Deleting Job '{job.Label}'")
        #     self.ProjectDocument.removeObject(job.Label)

        # Create the new job:
        job_name: str = f"{self.CurrentSolid.Label}_{label}"
        # if tracing:
        #     print(f"{tracing}Middle: {PathJob.Instances()=}")
        #     print(f"{tracing}Creating job {job_name}...")
        # job = PathJob.Create(job_name, [self.CurrentPart], None)
        # if tracing:
        #     instances: List[Any] = PathJob.Instances()
        #     print(f"{tracing}After: {job=} {instances=}")
        #     assert len(instances) == 1 and instances[0], "Not good"
        #     print(f"{tracing}{id(job)=} {id(instances[0])=}")
        #     assert len(instances) == 1 and instances[0], "Not good"
        job = PathJob.Create(job_name, [self.CurrentSolid], None)

        # drilling_name: str = f"{job_name}_Drilling"
        # assert PathDrilling.Create(drilling_name) is not None
        # self.ProjectDocument.removeObject(drilling_name)

        # TODO: Create a setupsheet and install it into the job.
        # setup_sheet: PathSetupSheet.SetupSheet = PathSetupSheet.Create()
        # job.SetupSheet = setup_sheet
        gcode_path: str = f"/tmp/{job_name}.ngc"
        job.PostProcessorOutputFile = gcode_path
        job.PostProcessor = 'linuxcnc'
        job.PostProcessorArgs = '--no-show-editor'
        job.Label = job_name
        self.CurrentJob = job
        self.CurrentJobName = job_name
        self.CurrentNormal = normal

        if App.GuiUp:  # type: ignore
            proxy: Any = PathJobGui.ViewProvider(job.ViewObject)
            # The statement below causes a bunch of rearrangement of the FreeCAD
            # object tree to push all off the Path related object to be under the
            # FreeCAD Path Job object.  This is really nice because it provides
            # the ability toggle the path trace visibility in one place.  The lovely
            # line below triggers a call to  PathJob.ObjectJob.__set__state__() method.
            # Which appears to do the rearrangement.  Unfortunately, this rearrangement
            # does not occur in embedded mode, so the resulting object trees look
            # quite different.  This is the FreeCAD way.
            job.ViewObject.Proxy = proxy  # This assignment rearranges the Job.

        if tracing:
            print(f"{tracing}<=FabCQtotFC.process_mount(*, {label}, {tree_path})")

    # CQtoFC.process_solid():
    def process_solid(self, json_dict: Dict[str, Any], label: str,
                      indent: str, tree_path: Tuple[str, ...], tracing: str = "") -> None:
        """Process a Solid JSON node."""
        next_tracing: str = tracing + " " if tracing else ""
        if tracing:
            print(f"{tracing}=>FabCQtotFC.process_solid(*, {label}, {tree_path})")

        self.flush_job(tracing=next_tracing)

        step_file: str = cast(str, self.key_verify("StepFile",
                                                   json_dict, str, tree_path, "Solid.StepFile"))
        if indent:
            print(f"{indent} StepFile: {step_file}")

        # This code currently trys to work with object in a seperate *steps_document* and
        # the main *project_document*.  Change the conditional to switch between.
        use_project_document: bool = True
        document: Any = self.ProjectDocument if use_project_document else self.StepsDocument
        before_size: int = len(document.RootObjects)
        FCImport.insert(step_file, document.Label)
        after_size: int = len(document.RootObjects)
        assert before_size + 1 == after_size, (before_size, after_size)
        solid: Any = document.getObject(label)
        solid.Label = f"{label}_Step"
        step_object: Any = document.RootObjects[before_size]
        step_object.Label = label

        # When the STEP files are colocated with the assemblies and such, the visibiliy
        # of the associated *gui_step_object* needs to be disabled.
        if use_project_document and App.GuiUp:  # type: ignore
            gui_document: Any = Gui.getDocument(document.Label)  # type: ignore
            gui_step_object: Any = gui_document.getObject(label)
            gui_step_object.Visibility = False

        # Install *link* into *group*.  Complete the link later on using *pending_links*:
        link: Any = self.CurrentGroup.newObject("App::Link", label)
        self.PendingLinks.append((link, solid))

        self.CurrentSolid = solid
        self.CurrentSolidName = label
        self.CurrentLink = link
        self.CurrentJob = None
        self.CurrentNormal = None

        if tracing:
            print(f"{tracing}<=FabCQtotFC.process_solid(*, {label}, {tree_path})")

    # CQtoFC.get_aligned_face_name():
    def get_aligned_face_name(self, obj: Any, normal: Vector, tracing: str = "") -> str:
        """Return top faces."""
        if tracing:
            print(f"{tracing}=>get_aligned_face_name({obj}, {normal})")
        assert hasattr(obj, "Shape")
        shape = obj.Shape
        face_index: int
        epsilon: float = 1.0e-8
        largest_area: float = 0.0
        largest_face_name: str = ""
        for face_index in range(len(shape.Faces)):
            face_name: str = f"Face{face_index+1}"
            face: Any = shape.getElement(face_name)
            if face.Orientation == 'Forward':
                delta: Vector = face.Surface.Axis - normal
                length: float = delta.Length
                if length < epsilon:
                    area = face.Area
                    if area > largest_area:
                        largest_area = area
                        largest_face_name = face_name
        if tracing:
            print(f"{tracing}<=get_aligned_faces_name({obj}, {normal})=>{largest_face_name}")
        return largest_face_name


# main():
def main(tracing: str = "") -> None:
    """The main program."""
    next_tracing: str = tracing + " " if tracing else ""
    if tracing:
        print(f"{tracing}=>main()")
    environ = cast(Dict[str, str], os.environ)
    json_file_name: str = environ["JSON"] if "JSON" in environ else "/tmp/TestProject.json"
    flags: str = environ["FLAGS"] if "FLAGS" in environ else ""
    cnc: bool = "c" in flags
    visual: bool = "v" in flags
    tools_path: Optional[Path] = FilePath(".") / "Tools" if cnc else None
    if tracing:
        print(f"{tracing}{json_file_name=} {tools_path=} {flags=} {cnc=} {visual=}")
    json_reader: FabCQtoFC = FabCQtoFC(FilePath(json_file_name), tools_path, cnc)
    json_reader.process(indent="  ", tracing=next_tracing)
    if not App.GuiUp:  # type: ignore
        if tracing:
            print(f"{tracing}calling sys.exit()")
        sys.exit(0)
    if tracing:
        print(f"{tracing}<=main()")


if __name__ == "__main__":
    main(tracing=" ")

# Miscellaneous links:
# [Add: New waterline algorithm](https://forum.freecad.org/viewtopic.php?f=15&t=65718)
# Post by sliptonic 02Feb2022@3:17PM describes the Path vs FreeCAD global coordinate systems.
